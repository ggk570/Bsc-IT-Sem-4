#### <span style="color:blue;">1. Explain RequestDispatcher interface with its methods.</span>
1. The `RequestDispatcher` interface in Java is part of the Java Servlet API, which provides methods to dispatch requests to other resources like servlets, JSPs, or HTML files on the server.
2. This interface is typically used in web applications to forward requests and responses or to include content from another resource in the response.
3. The client (browser) remains unaware of the forwarding process. The URL in the browser does not change; the forwarding is server-side.
4. It enables communication between different web components, allowing for modular development.
5. **Methods of RequestDispatcher interface:**
	1. **void forward(ServletRequest request, ServletResponse response):** Forwards a request from one servlet to another resource on the server (another servlet, JSP, or HTML page). The original request and response objects are passed to the forwarded resource. After the forward, the original servlet method completes and the response is generated by the forwarded resource and it is then sent to client.
	`RequestDispatcher dispatcher = request.getRequestDispatcher("/anotherServlet");`
	`dispatcher.forward(request, response);`
	2. **void include(ServletRequest request, ServletResponse response):** It is used to include the content of another resource (like another servlet or JSP) in the response. This method allows you to insert the output of another resource into the response of the current servlet. After calling include, the current servlet continues processing.
	`RequestDispatcher dispatcher = request.getRequestDispatcher("/header.jsp");`
	`dispatcher.include(request, response);`

#### <span style="color:blue;">2. What is Cookies? Explain setting, sending and reading Cookie in java servlet. Explain methods and properties of cookie object</span>
1. Cookies are small pieces of data stored on the client side (in the user's web browser) that are sent to the server with every request. Cookies are in key=value format.
2. They are commonly used to maintain state between requests, store user preferences, and manage session information.
3. By default, each request is considered as a new request. In cookies technique, we add cookie with response from the servlet.
4. After that if request is sent by the user, cookie is added with request by default. Thus, we recognize the user as the old user.
5. **Setting a cookie in a servlet:**
	1. To set a cookie we first need to create a cookie object. We can use below constructor to create a cookie:
	`Cookie ck = new Cookie(String key, String value);`
	2. We could also use a combination of default constructor and setName(String Name), setValue(String Value) methods to set a cookie.
	3. We could set expiry of cookie with setMaxAge(int seconds) method.
**Sending cookie:**
	1. To send a newly created cookie on server to client browser we need to add this cookie to response with below code:
	`response.addCookie(ck);`
	2. Once done, the browser will store the cookie and send it to server whenever it requests associated domain name.
**Reading cookie:**
	1. To read cookies sent by the client, we can retrieve them from the request using the `getCookies` method on the request object, this method will return Cookie array.
	`Cookie[] cookies = request.getCookies();`
	2. To fetch value of these cookies, we can iterate over the array:
```
for(int i=0;i<cookies.length;i++){
		String name = cookies[i].getName();
		String value = cookies[i].getValue();
		out.println(name + " : " + value);
	}
```
6. **Methods of Cookies:**
	1. **String getName():** This method is used to return the name of the cookie object.
	2. **String getValue():** This method is used to retrieve value of a cookie object.
	3. **String getDomain():** This is used to get the domain of the cookie, this specifies the domain and subdomain for which the cookie is valid.
	4. **String getPath():** It is used to get the URL path for which the cookie is valid
	5. **int getMaxAge():** Returns maximum age of cookie in seconds.
	6. **boolean getSecure():** Returns whether cookie is secure or not,  useful to check security restrictions against XSS attacks.
	7. **boolean getHttpOnly():** Returns whether the cookie is HttpOnly or not, useful to check security restrictions against XSS attacks.
	8. **void setName(String name):** Used to set the name of a cookie to be send to client.
	9. **void setValue(String value):** Used to set the value of cookie.
	10. **void setPath(String path):** Used to set the url path for which the cookie would be send by the client (browser).
	11. **void setDomain(String domain):** Sets the domain for which the cookie is valid.
	12. **void setMaxAge(int expiry):** Used to set the maximum age of a cookie in seconds, after this much seconds the cookie would be discarded by the client.
	13. **void setSecure(boolean secure):** Used to set the secure property of cookie to true or false.
	14. **void setHttpOnly(boolean HttpOnly):** Used to set whether the cookie is Http only or not, meaning it should be accessible by javascript code or not.

#### <span style="color:blue;">3. What is session? Explain lifecycle of Http Session.</span>
1. A **session** in web applications refers to a mechanism that allows the server to maintain state across multiple HTTP requests from the same client.
2. Since http is stateless protocol, there is no way for a server to differentiate requests coming from clients.
3. To cope this, a unique session identifier is created and assign to client as a cookie. If the server wants to store the state of the session, e.g if a user just logged in with valid password, the server could store a key:value pair indicating a valid authenticated session for the assigned session id. So whenever the same client sends a request with session id, the server will lookpup for required details associated with the session id, there by maintaining authenticated session.
4. Only session id is stored on client side and session data is stored on server side.
5. Methods of HttpSession object:
	1. **public HttpSession getSession():** Gets the HttpSession object.
	2. **public HttpSession getSession(boolean create):** Gets the session associated with the request. If not already present, then a new one is created based on the value of the boolean argument passed into it
	3. **public String getId():** Returns the unique session id
	4. **public long getCreationTime():** It returns the time when this session was created, measured in milliseconds since midnight January 1, 1970 GMT.
	5. **public long getLastAccessedTime():** It returns the time when this session was last accessed, measured in milliseconds since midnight January 1, 1970 GMT.
	6. **public void invalidate():** Invalidates the session
	7. **void setMaxInactiveInterval(int interval):** Sets the maximum time interval (in seconds) between client requests before the session is invalidated.
	8. **int getMaxInactiveInterval():** Returns the maximum time interval (in seconds) between client requests before the session is invalidated.
	9. **boolean isNew():** Returns true if the session was created during the current request, false otherwise.
	10. **void setAttribute(String name, Object value):** Binds an object to the session with the specified name.
	11. **Object getAttribute(String name):** Retrieves the object bound to the session with the specified name.
	12. **void removeAttribute(String name):** Removes the object bound to the session with the specified name.
	13. **Enumeration`<String>` getAttributeNames():** Returns an enumeration of all the attribute names bound to this session.
**LifeCycle of an HttpSession:**
1. In Java EE `HttpSession` interface provides a way to manage sessions. The life cycle of HttpSession is represented through various statges:
	1. **Session Creation:** To create a session, we can call request.getSession(true) method, if a session already exists, it will return an HttpSession object, if no session exists then it will create a new session and return newly created HttpSession object.
	`HttpSession session = request.getSession(true);`
	2. **Storing Attributes:** Once a session is created, we can store user-specific data as attributes, we can also remove already stored attributes. These can be achieved using:
	- **setAttribute(String name, Object value):** Adds or updates an attribute which is a key:value pair data to store for a specific session id.
	`session.setAttribute("username","Carl");`
	- **removeAttribute(String name):** Removes an attribute with specified name.
	3. **Accession Session data:** The client browser will submit session id with each subsequent requests. This allows server to indentify the associated session. To access session we need to get the session from request which can be done using code:
	`HttpSession session = request.getSession(true);`
	To  access attributes, we can use method:
	- **session.getAttribute(String AttrName):** It will retrieve value of attribute **AttrName**, the value would be returned as type **Object**, so we need to do explicit type conversion to access the value.
	4. **Session Timeout:** Sessions have a defined timeout period. If a user is inactive for this duration, the session expires, and all associated data is lost. The timeout can be configured in the web application’s deployment descriptor (`web.xml`) or programmatically.
	5. **Session Termination:** A session can be terminated explicitly by calling `session.invalidate()`, which removes the session and its attributes. Users may also terminate their session by logging out, which should also invoke `invalidate()`.

#### <span style="color:blue;">4. Explain the working of Non-Blocking IO.</span>
1. Non-blocking I/O is a technique that allows a program to perform I/O operations without blocking the execution of the program.
2. Non-blocking I/O is useful in situations where the program needs to perform I/O operations on multiple input/output streams simultaneously.
3. In non-blocking I/O, the program initiates an I/O operation and then continues executing other code without waiting for the I/O operation to complete.
4. When the I/O operation is complete, the program is notified and can then process the data that was read or written.
5. Non-blocking I/O works by using a special system call that allows the program to check if an I/O operation can be performed without blocking.
6. If an I/O operation can be performed without blocking, the program can initiate the operation and continue executing other code.
7. If an I/O operation would block, the program can choose to wait for the operation to complete or continue executing other code.
8. Non-blocking I/O is often used in network programming to handle multiple connections simultaneously. By using non-blocking I/O, a program can process data from multiple network connections without blocking on any one connection.
9. This can improve the performance of network applications and allow them to handle more connections simultaneously
#### <span style="color:blue;">5. Write a servlet application to upload and download a file.</span>
##### Application to Upload File
**index.html**
```
<!DOCTYPE html>
<html>
    <head>
        <title>Start Page</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>
    <body>
        <h1>File Upload</h1>
        <form action="FileUpload" method="post" enctype="multipart/form-data">
            Select file to upload:
            <br>
            <input type="file" id="input_file_upload" name="file">
            <br><br>
            <input type="submit" name="submit" value="Submit">
        </form>
        <a href="FileDownload/?filename=TimeTable.pdf">Download TimeTable</a>
        <a href="FileDownload/?filename=Hello.txt">Download Hello.txt</a>
    </body>
</html>
```
**FileUploadServlet.java**
```
import java.io.*;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.*;

@MultipartConfig
public class FileUpload extends HttpServlet {
    private File uploadPath;
    
     @Override
    public void init() throws ServletException {
        uploadPath = new File(getServletContext().getRealPath("") + File.separator + "uploads");
        if (!uploadPath.exists()) {
            uploadPath.mkdirs();
        }
    }
    
    protected void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        // Do Nothing
    }

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
        try (PrintWriter out = response.getWriter()) {
            out.println("<h1>Only Supports Post Request</h1>");
        }
    }
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
        try (PrintWriter out = response.getWriter()){
            Part filePart = request.getPart("file");
            String fileName = filePart.getSubmittedFileName();
            OutputStream outputFile = null;
            InputStream inputFile = null;
            try{
             File outputFileName = new File(uploadPath + File.separator + fileName);
             outputFile = new FileOutputStream(outputFileName);
             inputFile = filePart.getInputStream();
             int read = -1;
             byte[] buffer = new byte[4096];
             
             while((read = inputFile.read(buffer)) != -1){
                 outputFile.write(buffer);
             }
             out.print(fileName + " is uploaded successfully at ");
             out.println();
             out.println("<a href='uploads/" + fileName + "'>this link</a>");
            }
            catch(Exception e){
                out.println("<h3>File could not be saved due to exception</h3>");
                out.println(e);
            }
            finally{
                outputFile.close();
            }
        }
    }
    @Override
    public String getServletInfo() {
        return "Short description";
    }
}
```
**FileDownloadServlet.java**
```
import java.io.*;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.*;
import jakarta.servlet.ServletContext;
import java.net.URLConnection;

public class FileDownload extends HttpServlet {

    protected void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        InputStream inputFile = null;
        try (PrintWriter out = response.getWriter()) {
            String filename = request.getParameter("filename");
            String mimeType = URLConnection.guessContentTypeFromName(filename);
            response.setContentType(mimeType);
            ServletContext context = request.getServletContext();
            try{
                inputFile = context.getResourceAsStream("/" + filename); 
                response.setHeader("Content-Disposition", "attachment;filename=\"" + filename + "\"");
                int read;
                while((read = inputFile.read()) != -1){
                    out.write(read);
                }
            }
            catch(Exception e){
                out.println(e.getMessage());
            }
            finally{
                if(inputFile != null)
                    inputFile.close();
            }
        }
    }

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        processRequest(request, response);
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        processRequest(request, response);
    }

    @Override
    public String getServletInfo() {
        return "Short description";
    }
}
```

#### <span style="color:blue;">6. Which things need to be carefully checked and understood while writing file uploading code in servlet ?</span>
1. When writing file uploading code in a servlet, there are several things that need to be carefully checked and understood to ensure that the code is secure and reliable:
	1. **Request Method:** The file upload request must use the POST method, as other methods like GET or HEAD do not support file uploads.
	2. **Encoding Type:** The encoding type of the request must be set to "multipart/form-data", which allows binary data to be included in the request body.
	3. **File Size:** The maximum file size that can be uploaded should be limited to prevent denial of service attacks and to ensure that the server has enough resources to handle the request
	4. **File Type:** The file type should be validated to ensure that only allowed file types are uploaded. This can be done by checking the file extension or by checking the MIME type of the file.
	5. **File Name:** The file name should be sanitized to prevent directory traversal attacks. The file name should also be checked for length to prevent buffer overflow attacks
	6. **File Storage:** The uploaded file should be stored in a secure location on the server, and the file should be given a unique name to prevent conflicts with other files.
	7. **Error Handling:** The servlet should handle errors gracefully and provide informative error messages to the user. This can include checking for file upload errors, file size errors, and file type errors
	8. **Security:** The servlet should be protected against cross-site scripting (XSS) and cross-site request forgery (CSRF) attacks.

#### <span style="color:blue;">7. Write a servlet program to create a session and display: Session ID, New or Old, Creation Time</span>
**index.html**
```
<!DOCTYPE html>
<html>
    <head>
        <title>Start Page</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>
    <body>
        <script>
            window.location("/SessionServlet")
        </script>
    </body>
</html>
```
**SessionServlet**
```
import java.io.IOException;
import java.io.PrintWriter;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.*;

public class SessionServlet extends HttpServlet {

    protected void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
        
        HttpSession session = request.getSession(true);    
        String sessionId = session.getId();
        long creationTime = session.getCreationTime();
        String stmtForNewSession = session.isNew() ? "is new" : "is not new";
        
        try (PrintWriter out = response.getWriter()) {
            out.println("<!DOCTYPE html>");
            out.println("<html>");
            out.println("<head>");
            out.println("<title>Servlet SessionServlet</title>");
            out.println("</head>");
            out.println("<body>");
            out.println("<h3>Your session id is: " + sessionId + "</h3>");
            out.println("<h3>Your session is: " + stmtForNewSession + "</h3>");
            out.println("<h3>Your session is created at " + new java.util.Date(creationTime) + "<h3>");
            out.println("</body>");
            out.println("</html>");
        }
    }

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        processRequest(request, response);
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        processRequest(request, response);
    }

    @Override
    public String getServletInfo() {
        return "Short description";
    }// </editor-fold>

}
```

#### <span style="color:blue;">8. Write a servlet program GradeServlet.java that accepts grades through radio button in index.html and if grade is A, B, C or D the user should be redirected to Success.html displaying success message and if user is failed it should display try again and load index.html</span>
**index.html**
```
<!DOCTYPE html>
<html>
    <head>
        <title>Start Page</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>
    <body>
        <form action="GradeServlet" method="post">
            <label>
                <input type="radio" name="grade" value="A">
                A Grade
            </label>
            <br>
            <label>
                <input type="radio" name="grade" value="B">
                B Grade
            </label>
            <br>
            <label>
                <input type="radio" name="grade" value="C">
                C Grade
            </label>
            <br>
            <label>
                <input type="radio" name="grade" value="D">
                D Grade
            </label>
            <br>
            <label>
                <input type="radio" name="grade" value="F">
                F Grade
            </label>
            <br><br>
            <input type="submit" value="Submit">
        </form>
    </body>
</html>
```
**GradeServlet.java**
```
import jakarta.servlet.RequestDispatcher;
import java.io.IOException;
import java.io.PrintWriter;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.*;

public class GradeServlet extends HttpServlet {

    protected void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
        try (PrintWriter out = response.getWriter()) {
            String grade = request.getParameter("grade");
            if(grade.equals("A") || grade.equals("B") || grade.equals("C") || grade.equals("D")){
                response.sendRedirect("Success.html");
            }
            else if(grade.equals("F")){
                out.println("Try Again");
                RequestDispatcher rd = request.getRequestDispatcher("index.html");
                rd.include(request, response);
            }
            else{
            out.println("<!DOCTYPE html>");
            out.println("<html>");
            out.println("<head>");
            out.println("<title>Servlet GradeServlet</title>");
            out.println("</head>");
            out.println("<body>");
            out.println("</body>");
            out.println("</html>");
            }
        }
    }

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        processRequest(request, response);
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        processRequest(request, response);
    }
    @Override
    public String getServletInfo() {
        return "Short description";
    }
}
```

#### <span style="color:blue;">9. Explain the following w.r.t working with files</span>
**i) @MultipartConfig**
`@MultipartConfig` is an annotation used in Java EE (now Jakarta EE) to indicate that a servlet can handle multipart/form-data requests. This is commonly used for file uploads. By applying this annotation, the servlet becomes capable of processing requests that include files, allowing developers to access the uploaded file(s) via the servlet's request object.
**ii) fileSizeThreshold**
The `fileSizeThreshold` parameter specifies the size (in bytes) at which files should be temporarily stored on disk rather than in memory. If an uploaded file exceeds this threshold, it will be written to a temporary file on the server's filesystem. This is useful for managing memory usage, especially when handling large files.
**ii) location**
The `location` parameter determines where the temporary files will be stored on the server. This is typically a directory path where the servlet can write the uploaded files that exceed the `fileSizeThreshold`. Specifying a proper location helps ensure that the server has enough space and proper permissions to handle the uploaded files.
**iv) maxFileSize**
The `maxFileSize` parameter sets the maximum size (in bytes) that an individual uploaded file can have. If a user attempts to upload a file larger than this limit, the server will reject the upload and typically return an error response. This is important for protecting the server from excessively large uploads that could impact performance or storage.
**v) maxRequestSize**
The `maxRequestSize` parameter defines the maximum size (in bytes) of the entire request, including all uploaded files and any form data. If the total size of the request exceeds this limit, the server will reject the request. This is useful for enforcing limits on the total amount of data that can be uploaded in a single submission.

#### <span style="color:blue;">10. Explain using a code snippet the onDataAvailable() and onAllDataRead() methods of ReadListener interface</span>
1. The `ReadListener` interface is part of the Java Servlet API and is used for asynchronous processing of data from a servlet's request. It provides methods that allow you to handle data as it becomes available and to take action when all data has been read.
2. **Overview of Methods:**
	1. **onDataAvailable()**: This method is called when there is data available to read from the request. You would typically implement this method to read the data in chunks as it arrives.
	2. **onAllDataRead()**: This method is called when all data has been read from the request. You can use this method to perform any final processing after reading all the data.
3. **`onAllDataRead()`**: This method is called when all data has been read from the request. You can use this method to perform any final processing after reading all the data.
```
import javax.servlet.annotation.WebServlet;
import javax.servlet.AsyncContext;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.ReadListener;
import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServlet;
import java.io.IOException;

@WebServlet(urlPatterns = "/upload", asyncSupported = true)
public class AsyncUploadServlet extends HttpServlet {

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // Start asynchronous processing
        AsyncContext asyncContext = request.startAsync();
        ServletInputStream inputStream = request.getInputStream();
        
        // Set the ReadListener
        inputStream.setReadListener(new ReadListener() {
            @Override
            public void onDataAvailable() throws IOException {
                while (inputStream.isReady()) {
                    byte[] buffer = new byte[1024];
                    int bytesRead = inputStream.read(buffer);
                    
                    if (bytesRead > 0) {
                        // Process the data (e.g., store it or log it)
                        System.out.println(new String(buffer, 0, bytesRead));
                    }
                }
            }

            @Override
            public void onAllDataRead() throws IOException {
                // All data has been read; complete the async context
                System.out.println("All data has been read.");
                asyncContext.complete();
            }

            @Override
            public void onError(Throwable t) {
                // Handle errors
                t.printStackTrace();
                asyncContext.complete();
            }
        });
    }
}
```

#### <span style="color:blue;">11. What is Non-Blocking I/O? Explain WriteListener and ReadListener performing in NonBlocking I/O?</span>
1. Non-Blocking I/O (Input/Output) is a programming paradigm that allows operations to proceed without being blocked, enabling applications to handle multiple tasks simultaneously.
2. In the context of web applications and servers, this means that instead of waiting for I/O operations (like reading from or writing to a file or network socket) to complete, the application can continue executing other code, improving performance and responsiveness.
3. Key Concepts of Non-Blocking I/O:
	- **Asynchronous Processing**: The application can initiate an I/O operation and continue executing without waiting for that operation to complete.
	- **Callbacks**: Instead of returning a result directly, non-blocking operations typically use callback mechanisms to notify the application when an operation has completed or when data is available.
	- **Efficiency**: This approach is particularly beneficial in high-concurrency environments, where many I/O operations can be managed without requiring multiple threads.
4. In the context of Java Servlet API, the `WriteListener` and `ReadListener` interfaces are used for handling non-blocking I/O operations in servlets.
5. **ReadListener:** The `ReadListener` interface is used with `ServletInputStream` to handle incoming data asynchronously. It provides methods to process data as it becomes available.
	**Methods**:
    - **`onDataAvailable()`**: Called when there is data ready to be read from the input stream. You implement this method to read the available data.
    - **`onAllDataRead()`**: Called when all the data has been read. This is where you can finalize processing, like sending a response.
    - **`onError(Throwable t)`**: Called when an error occurs during reading. This allows you to handle exceptions and clean up resources.
```
inputStream.setReadListener(new ReadListener() {
    @Override
    public void onDataAvailable() throws IOException {
        while (inputStream.isReady()) {
            byte[] buffer = new byte[1024];
            int bytesRead = inputStream.read(buffer);
            // Process the data
        }
    }

    @Override
    public void onAllDataRead() throws IOException {
        // Handle completion
    }

    @Override
    public void onError(Throwable t) {
        // Handle error
    }
});
```
6. **WriteListener:** The `WriteListener` interface is used with `ServletOutputStream` to handle outgoing data asynchronously. It allows you to send data to the client without blocking the main thread.
	**Methods:**
	- **`onWritePossible()`**: Called when the output stream is ready for more data to be written. You can implement this method to write data to the response.
	- **`onError(Throwable t)`**: Called when an error occurs during writing, allowing for error handling and cleanup.
```
outputStream.setWriteListener(new WriteListener() {
    @Override
    public void onWritePossible() throws IOException {
        while (outputStream.isReady()) {
            // Write data to the output stream
            outputStream.write(data);
        }
    }

    @Override
    public void onError(Throwable t) {
        // Handle error
    }
});
```
